{"version":3,"sources":["../src/index.ts","../src/schemas.ts","../src/is-defined.ts","../src/remark-plugins/translate-to-nextra.ts","../src/flatten-schema-properties.ts"],"sourcesContent":["export * from './schemas';\nexport * from './is-defined';\nexport * from './flatten-schema-properties';\nexport * from './remark-plugins/translate-to-nextra';\n","import { Octokit } from '@octokit/rest';\nimport { JSONSchema7 } from 'json-schema';\nimport { Plugin } from 'unified';\nimport {\n  flattenSchemaProperties,\n  SchemaProperty,\n} from './flatten-schema-properties';\n\ninterface Schemas {\n  schemas: Record<string, JSONSchema7>;\n  latestVersion: string | undefined;\n}\n\n// cache per-build/dev server\nlet schemasCache: Schemas | undefined;\n\nexport async function getSchemas(): Promise<Schemas> {\n  if (schemasCache) {\n    return schemasCache;\n  }\n\n  const client = new Octokit({ auth: process.env.GITHUB_TOKEN });\n\n  const repoParams = { owner: 'blake-mealey', repo: 'mantle' };\n\n  const releases = await client.paginate(\n    client.rest.repos.listReleases,\n    repoParams\n  );\n\n  const schemas: Record<string, JSONSchema7> = {};\n\n  await Promise.all(\n    releases.map(async (release) => {\n      const asset_id = release.assets.find(\n        (asset) => asset.name === 'schema.json'\n      )?.id;\n\n      if (!asset_id) return;\n\n      const response = await client.rest.repos.getReleaseAsset({\n        ...repoParams,\n        asset_id,\n        headers: {\n          accept: 'application/octet-stream',\n        },\n      });\n\n      schemas[release.tag_name] = JSON.parse(\n        Buffer.from(response.data as any).toString('utf8')\n      );\n    })\n  );\n\n  schemasCache = { schemas, latestVersion: releases[0]?.tag_name };\n  return schemasCache;\n}\n\nexport interface Schema {\n  version: string;\n  properties: SchemaProperty[];\n}\n\nexport type CompileMdx = (\n  md: string,\n  options: { mdxOptions: { remarkPlugins: Plugin[] } }\n) => Promise<{ result: string }>;\n\nexport async function processSchema(\n  compileMdx: CompileMdx,\n  {\n    version,\n    schema,\n  }: {\n    version: string;\n    schema: JSONSchema7;\n  }\n): Promise<Schema> {\n  return {\n    version,\n    properties: await flattenSchemaProperties(compileMdx, schema),\n  };\n}\n","export function isDefined<T>(value: T | undefined | null): value is T {\n  return value !== undefined && value !== null;\n}\n","import { Processor } from '@mdx-js/mdx/lib/core';\nimport { u } from 'unist-builder';\nimport { visit } from 'unist-util-visit';\nimport { Plugin } from 'unified';\n\ninterface CodeNode {\n  lang?: string;\n  meta?: string;\n}\n\ninterface ParagraphNode {\n  children: ParagraphChildNode[];\n}\n\ninterface ParagraphChildNode {\n  value: string;\n}\n\nconst admonitionTypeToCalloutType: Record<string, string> = {\n  note: 'default',\n  tip: 'default',\n  info: 'info',\n  caution: 'warning',\n  danger: 'error',\n};\n\n// Our docs were originally written for Docusaurus, which has different\n// syntax for some features. We run the markdown through a remark plugin\n// to translate to Nextra's syntax.\nexport const translateToNextra: Plugin<[]> = function (this: Processor) {\n  return (tree, _file, done) => {\n    visit(tree, [{ type: 'code' }], (node) => {\n      const codeNode = node as CodeNode;\n\n      // Shiki currently only supports the \"yaml\" file extension for YAML\n      // See PR to fix this here: https://github.com/shikijs/shiki/pull/399\n      if (codeNode.lang === 'yml') {\n        codeNode.lang = 'yaml';\n      }\n\n      // Docusaurus uses the `title` attribute to specify the filename\n      if (codeNode.meta) {\n        codeNode.meta = codeNode.meta.replace(/title=\"(.*)\"/, 'filename=\"$1\"');\n      }\n    });\n\n    // Docusaurus uses `:::type` admonitions syntax, while Nextra uses the\n    // `<Callout type=\"\">` component.\n    visit(tree, [{ type: 'paragraph' }], (node, index, parent: any) => {\n      const paragraphNode = node as unknown as ParagraphNode;\n      const firstChild = paragraphNode.children[0] as\n        | ParagraphChildNode\n        | undefined;\n\n      if (firstChild?.value.startsWith(':::')) {\n        const match = firstChild.value.match(/^:::(\\w*)\\s*\\n/);\n        const type = match?.[1];\n\n        firstChild.value = firstChild?.value.replace(/^:::.*\\n/, '');\n\n        const lastChild =\n          paragraphNode.children[paragraphNode.children.length - 1];\n        lastChild!.value = lastChild!.value.split('\\n').slice(0, -1).join('\\n');\n\n        const calloutType =\n          admonitionTypeToCalloutType[type ?? 'note'] ?? 'default';\n        const callout = u('mdxJsxFlowElement', {\n          name: 'Callout',\n          attributes: [\n            { type: 'mdxJsxAttribute', name: 'type', value: calloutType },\n          ],\n          children: paragraphNode.children,\n          data: { _mdxExplicitJsx: true },\n        });\n\n        parent.children.splice(index as number, 1, callout);\n      }\n    });\n\n    done();\n  };\n};\n","import { JSONSchema7, JSONSchema7TypeName, JSONSchema7Type } from 'json-schema';\nimport { isDefined } from './is-defined';\nimport { translateToNextra } from './remark-plugins/translate-to-nextra';\nimport { CompileMdx } from './schemas';\n\nexport interface SchemaProperty {\n  id: string;\n  required: boolean;\n  level: number;\n  compiledContent: string | null;\n  propertyType: PropertyType;\n  default: { value: JSONSchema7Type } | null;\n}\n\nexport async function flattenSchemaProperties(\n  compileMdx: CompileMdx,\n  schema: JSONSchema7,\n  parentId?: string\n) {\n  if ((schema as Record<string, any>)['x-skip-properties']) {\n    return [];\n  }\n\n  let properties: SchemaProperty[] = [];\n\n  const requiredProps = schema.required ?? [];\n\n  if (isType(schema, 'object')) {\n    if (schema.properties) {\n      for (const [id, definition] of Object.entries(schema.properties)) {\n        if (typeof definition === 'boolean') {\n          continue;\n        }\n        const formattedId = formatId(id, parentId);\n\n        properties.push({\n          id: formattedId,\n          level: getLevel(formattedId),\n          required: requiredProps.includes(id),\n          compiledContent: definition.description\n            ? (\n                await compileMdx(definition.description, {\n                  mdxOptions: { remarkPlugins: [translateToNextra] },\n                })\n              ).result\n            : null,\n          propertyType: getSchemaPropertyType(definition),\n          default:\n            definition.default === undefined\n              ? null\n              : { value: definition.default },\n        });\n        properties.push(\n          ...(await flattenSchemaProperties(\n            compileMdx,\n            definition,\n            formattedId\n          ))\n        );\n      }\n    }\n    if (\n      schema.additionalProperties &&\n      typeof schema.additionalProperties !== 'boolean'\n    ) {\n      properties.push(\n        ...(await flattenSchemaProperties(\n          compileMdx,\n          schema.additionalProperties,\n          formatId('<label>', parentId)\n        ))\n      );\n    }\n  } else if (isType(schema, 'array')) {\n    const items = Array.isArray(schema.items) ? schema.items : [schema.items];\n    for (const definition of items) {\n      if (!definition || typeof definition === 'boolean') {\n        continue;\n      }\n      properties.push(\n        ...(await flattenSchemaProperties(\n          compileMdx,\n          definition,\n          formatId('*', parentId)\n        ))\n      );\n    }\n  } else if (schema.oneOf) {\n    for (const definition of schema.oneOf) {\n      if (typeof definition === 'boolean') {\n        continue;\n      }\n      properties.push(\n        ...(await flattenSchemaProperties(compileMdx, definition, parentId))\n      );\n    }\n  } else if (schema.anyOf) {\n    for (const definition of schema.anyOf) {\n      if (typeof definition === 'boolean') {\n        continue;\n      }\n      properties.push(\n        ...(await flattenSchemaProperties(compileMdx, definition, parentId))\n      );\n    }\n  } else {\n    if (\n      schema.type !== 'string' &&\n      schema.type !== 'integer' &&\n      schema.type !== 'boolean' &&\n      schema.type !== 'number'\n    )\n      console.log(schema.type, Object.keys(schema));\n  }\n\n  return properties;\n}\n\nfunction isType(schema: JSONSchema7, type: JSONSchema7TypeName) {\n  if (!schema.type) {\n    return false;\n  }\n  if (Array.isArray(schema.type)) {\n    return schema.type.includes(type);\n  } else {\n    return schema.type === type;\n  }\n}\n\nexport type PropertyType =\n  | { type: 'primitive'; value: string }\n  | { type: 'enum'; values: PropertyType[] }\n  | { type: 'array'; valueType: PropertyType }\n  | { type: 'dictionary'; valueType: PropertyType }\n  | { type: 'object'; properties: [string, PropertyType][] }\n  | { type: 'oneOf'; values: PropertyType[] }\n  | { type: 'anyOf'; values: PropertyType[] };\n\nfunction getValuePropertyType(type: JSONSchema7Type): PropertyType {\n  if (typeof type === 'object') {\n    if (Array.isArray(type)) {\n      const item = type[0];\n      return {\n        type: 'array',\n        valueType: item\n          ? getValuePropertyType(item)\n          : { type: 'primitive', value: 'unknown' },\n      };\n    }\n    // TODO: include object properties?\n    return {\n      type: 'primitive',\n      value: 'object',\n    };\n  }\n  return {\n    type: 'primitive',\n    value: type.toString(),\n  };\n}\n\nfunction getSchemaPropertyType(schema: JSONSchema7): PropertyType {\n  let type: string | undefined;\n  if (Array.isArray(schema.type)) {\n    type = schema.type.find((x) => x !== 'null');\n  } else {\n    type = schema.type;\n  }\n\n  if (schema.enum) {\n    let values = schema.enum;\n    if (type === 'string') {\n      values = values.map((value) => `'${value}'`);\n    }\n    return {\n      type: 'enum',\n      values: values.map(getValuePropertyType),\n    };\n  }\n\n  if (type === 'number' || type === 'integer') {\n    return {\n      type: 'primitive',\n      value: schema.format ?? type,\n    };\n  }\n\n  if (\n    type === 'array' &&\n    schema.items &&\n    typeof schema.items !== 'boolean' &&\n    !Array.isArray(schema.items)\n  ) {\n    return {\n      type: 'array',\n      valueType: getSchemaPropertyType(schema.items),\n    };\n  }\n\n  if (type === 'object') {\n    if (schema.additionalProperties) {\n      return {\n        type: 'dictionary',\n        valueType:\n          typeof schema.additionalProperties !== 'boolean'\n            ? getSchemaPropertyType(schema.additionalProperties)\n            : { type: 'primitive', value: 'unknown' },\n      };\n    }\n    return {\n      type: 'object',\n      properties: Object.entries(schema.properties ?? {})\n        .map(([name, property]): [string, PropertyType] | undefined =>\n          typeof property !== 'boolean'\n            ? [name, getSchemaPropertyType(property)]\n            : undefined\n        )\n        .filter(isDefined),\n    };\n  }\n\n  if (schema.oneOf) {\n    const oneOf = {\n      type: 'oneOf',\n      values: schema.oneOf\n        .filter(\n          (definition): definition is JSONSchema7 =>\n            typeof definition !== 'boolean'\n        )\n        .map(getSchemaPropertyType),\n    } as const;\n    if (oneOf.values.length === 1) {\n      return oneOf.values[0]!;\n    }\n    return oneOf;\n  }\n\n  if (schema.anyOf) {\n    const anyOf = {\n      type: 'anyOf',\n      values: schema.anyOf\n        .filter(\n          (definition): definition is JSONSchema7 =>\n            typeof definition !== 'boolean'\n        )\n        .map(getSchemaPropertyType),\n    } as const;\n    if (anyOf.values.length === 1) {\n      return anyOf.values[0]!;\n    }\n    return anyOf;\n  }\n\n  return {\n    type: 'primitive',\n    value: type ?? 'unknown',\n  };\n}\n\nfunction formatId(id: string, parentId?: string) {\n  return (parentId ? `${parentId}.` : '') + id;\n}\n\nfunction getLevel(id: string) {\n  // flat after first level\n  return id.includes('.') ? 4 : 3;\n\n  // flat after 6th level\n  // return Math.min(\n  //   6,\n  //   Array.from(id).reduce(\n  //     (n, c) => (c === '.' ? n + 1 : c === '*' ? n - 1 : n),\n  //     3\n  //   )\n  // );\n}\n"],"mappings":"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","names":["_a"]}